--- ../ble_app_hids_keyboard/main.c	2016-10-04 14:09:12.000000000 +0200
+++ main.c	2016-10-13 11:20:59.795749477 +0200
@@ -26,6 +26,7 @@
  * Also it would accept pairing requests from any peer device.
  */
 
+#include <nrf_nvic.h>
 #include <stdint.h>
 #include <string.h>
 #include "nordic_common.h"
@@ -42,9 +43,6 @@
 #include "ble_bas.h"
 #include "ble_dis.h"
 #include "ble_conn_params.h"
-#include "bsp.h"
-#include "sensorsim.h"
-#include "bsp_btn_ble.h"
 #include "app_scheduler.h"
 #include "softdevice_handler_appsh.h"
 #include "app_timer_appsh.h"
@@ -53,14 +51,14 @@
 #include "fds.h"
 #include "fstorage.h"
 #include "ble_conn_state.h"
+#include "ble_radio_notification.h"
+#include "joy.h"
+#include "time.h"
 
 #define NRF_LOG_MODULE_NAME "APP"
 #include "nrf_log.h"
 #include "nrf_log_ctrl.h"
 
-#if BUTTONS_NUMBER < 2
-#error "Not enough resources on board"
-#endif
 
 #if (NRF_SD_BLE_API_VERSION == 3)
 #define NRF_BLE_MAX_MTU_SIZE            GATT_MTU_SIZE_DEFAULT                       /**< MTU size used in the softdevice enabling and to reply to a BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST event. */
@@ -72,20 +70,16 @@
 #define UART_TX_BUF_SIZE                 256                                        /**< UART TX buffer size. */
 #define UART_RX_BUF_SIZE                 1                                          /**< UART RX buffer size. */
 
-#define KEY_PRESS_BUTTON_ID              0                                          /**< Button used as Keyboard key press. */
-#define SHIFT_BUTTON_ID                  1                                          /**< Button used as 'SHIFT' Key. */
-
-#define DEVICE_NAME                      "Nordic_Keyboard"                          /**< Name of device. Will be included in the advertising data. */
-#define MANUFACTURER_NAME                "NordicSemiconductor"                      /**< Manufacturer. Will be passed to Device Information Service. */
+#if defined(ARCADE_INPUT)
+#define DEVICE_NAME                      "Arcade Gamepad"                          /**< Name of device. Will be included in the advertising data. */
+#else
+#define DEVICE_NAME                      "Analog Gamepad"
+#endif
+#define MANUFACTURER_NAME                "DIY"                      /**< Manufacturer. Will be passed to Device Information Service. */
 
 #define APP_TIMER_PRESCALER              0                                          /**< Value of the RTC1 PRESCALER register. */
 #define APP_TIMER_OP_QUEUE_SIZE          4                                          /**< Size of timer operation queues. */
 
-#define BATTERY_LEVEL_MEAS_INTERVAL      APP_TIMER_TICKS(2000, APP_TIMER_PRESCALER) /**< Battery level measurement interval (ticks). */
-#define MIN_BATTERY_LEVEL                81                                         /**< Minimum simulated battery level. */
-#define MAX_BATTERY_LEVEL                100                                        /**< Maximum simulated battery level. */
-#define BATTERY_LEVEL_INCREMENT          1                                          /**< Increment between each simulated battery level measurement. */
-
 #define PNP_ID_VENDOR_ID_SOURCE          0x02                                       /**< Vendor ID Source. */
 #define PNP_ID_VENDOR_ID                 0x1915                                     /**< Vendor ID. */
 #define PNP_ID_PRODUCT_ID                0xEEEE                                     /**< Product ID. */
@@ -97,10 +91,16 @@
 #define APP_ADV_SLOW_TIMEOUT             180                                        /**< The duration of the slow advertising period (in seconds). */
 
 /*lint -emacro(524, MIN_CONN_INTERVAL) // Loss of precision */
-#define MIN_CONN_INTERVAL                MSEC_TO_UNITS(7.5, UNIT_1_25_MS)            /**< Minimum connection interval (7.5 ms) */
-#define MAX_CONN_INTERVAL                MSEC_TO_UNITS(30, UNIT_1_25_MS)             /**< Maximum connection interval (30 ms). */
+#define MIN_CONN_INTERVAL                12            /**< Minimum connection interval (7.5 ms) */
+#define MAX_CONN_INTERVAL                24             /**< Maximum connection interval (20 ms). */
+
+#if defined(ARCADE_INPUT)
 #define SLAVE_LATENCY                    6                                           /**< Slave latency. */
-#define CONN_SUP_TIMEOUT                 MSEC_TO_UNITS(430, UNIT_10_MS)              /**< Connection supervisory timeout (430 ms). */
+#define CONN_SUP_TIMEOUT                 100              /**< Connection supervisory timeout (1000 ms). */
+#else
+#define SLAVE_LATENCY                    0                                           /**< Slave latency. */
+#define CONN_SUP_TIMEOUT                 100              /**< Connection supervisory timeout (1000 ms). */
+#endif
 
 #define FIRST_CONN_PARAMS_UPDATE_DELAY   APP_TIMER_TICKS(5000, APP_TIMER_PRESCALER)  /**< Time from initiating event (connect or start of notification) to first time sd_ble_gap_conn_param_update is called (5 seconds). */
 #define NEXT_CONN_PARAMS_UPDATE_DELAY    APP_TIMER_TICKS(30000, APP_TIMER_PRESCALER) /**< Time between each call to sd_ble_gap_conn_param_update after the first call (30 seconds). */
@@ -115,65 +115,31 @@
 #define SEC_PARAM_MIN_KEY_SIZE           7                                           /**< Minimum encryption key size. */
 #define SEC_PARAM_MAX_KEY_SIZE           16                                          /**< Maximum encryption key size. */
 
-#define OUTPUT_REPORT_INDEX              0                                           /**< Index of Output Report. */
-#define OUTPUT_REPORT_MAX_LEN            1                                           /**< Maximum length of Output Report. */
-#define INPUT_REPORT_KEYS_INDEX          0                                           /**< Index of Input Report. */
-#define OUTPUT_REPORT_BIT_MASK_CAPS_LOCK 0x02                                        /**< CAPS LOCK bit in Output Report (based on 'LED Page (0x08)' of the Universal Serial Bus HID Usage Tables). */
-#define INPUT_REP_REF_ID                 0                                           /**< Id of reference to Keyboard Input Report. */
-#define OUTPUT_REP_REF_ID                0                                           /**< Id of reference to Keyboard Output Report. */
-
 #define APP_FEATURE_NOT_SUPPORTED        BLE_GATT_STATUS_ATTERR_APP_BEGIN + 2        /**< Reply when unsupported features are requested. */
-
-#define MAX_BUFFER_ENTRIES               5                                           /**< Number of elements that can be enqueued */
-
 #define BASE_USB_HID_SPEC_VERSION        0x0101                                      /**< Version number of base USB HID Specification implemented by this application. */
-
-#define INPUT_REPORT_KEYS_MAX_LEN        8                                           /**< Maximum length of the Input Report characteristic. */
-
 #define DEAD_BEEF                        0xDEADBEEF                                  /**< Value used as error code on stack dump, can be used to identify stack location on stack unwind. */
-
 #define SCHED_MAX_EVENT_DATA_SIZE        MAX(APP_TIMER_SCHED_EVT_SIZE, \
                                              BLE_STACK_HANDLER_SCHED_EVT_SIZE)       /**< Maximum size of scheduler events. */
-#ifdef SVCALL_AS_NORMAL_FUNCTION
-#define SCHED_QUEUE_SIZE                 20                                          /**< Maximum number of events in the scheduler queue. More is needed in case of Serialization. */
-#else
 #define SCHED_QUEUE_SIZE                 10                                          /**< Maximum number of events in the scheduler queue. */
-#endif
 
-#define MODIFIER_KEY_POS                 0                                           /**< Position of the modifier byte in the Input Report. */
-#define SCAN_CODE_POS                    2                                           /**< This macro indicates the start position of the key scan code in a HID Report. As per the document titled 'Device Class Definition for Human Interface Devices (HID) V1.11, each report shall have one modifier byte followed by a reserved constant byte and then the key scan code. */
-#define SHIFT_KEY_CODE                   0x02                                        /**< Key code indicating the press of the Shift Key. */
-
-#define MAX_KEYS_IN_ONE_REPORT           (INPUT_REPORT_KEYS_MAX_LEN - SCAN_CODE_POS) /**< Maximum number of key presses that can be sent in one Input Report. */
-
-
-/**Buffer queue access macros
- *
- * @{ */
-/** Initialization of buffer list */
-#define BUFFER_LIST_INIT()     \
-    do                         \
-    {                          \
-        buffer_list.rp    = 0; \
-        buffer_list.wp    = 0; \
-        buffer_list.count = 0; \
-    } while (0)
-
-/** Provide status of data list is full or not */
-#define BUFFER_LIST_FULL() \
-    ((MAX_BUFFER_ENTRIES == buffer_list.count - 1) ? true : false)
-
-/** Provides status of buffer list is empty or not */
-#define BUFFER_LIST_EMPTY() \
-    ((0 == buffer_list.count) ? true : false)
-
-#define BUFFER_ELEMENT_INIT(i)                 \
-    do                                         \
-    {                                          \
-        buffer_list.buffer[(i)].p_data = NULL; \
-    } while (0)
+#ifdef DEBUG
+#define TIMEOUT_IN_MS 60000
+#else
+#define TIMEOUT_IN_MS 1000 * 60 * 5
+#endif
+#define MIN_REPORT_PERIOD_IN_MS 10000
 
-/** @} */
+#define TIMER_INPUT_TICK 33 //1 tick = 30,517578125 us => 33 ticks = 1007,080078125 us
+//static uint16_t report_period_counter = MIN_REPORT_PERIOD_IN_MS;
+static uint32_t timeout_counter = TIMEOUT_IN_MS;
+
+// From pca10028.h because bsp directory is removed from project
+#ifndef NRF_CLOCK_LFCLKSRC
+#define NRF_CLOCK_LFCLKSRC      {.source        = NRF_CLOCK_LF_SRC_XTAL,            \
+                                 .rc_ctiv       = 0,                                \
+                                 .rc_temp_ctiv  = 0,                                \
+                                 .xtal_accuracy = NRF_CLOCK_LF_XTAL_ACCURACY_20_PPM}
+#endif
 
 typedef enum
 {
@@ -185,40 +151,15 @@
     BLE_SLEEP,              /**< Go to system-off. */
 } ble_advertising_mode_t;
 
-/** Abstracts buffer element */
-typedef struct hid_key_buffer
-{
-    uint8_t      data_offset; /**< Max Data that can be buffered for all entries */
-    uint8_t      data_len;    /**< Total length of data */
-    uint8_t    * p_data;      /**< Scanned key pattern */
-    ble_hids_t * p_instance;  /**< Identifies peer and service instance */
-} buffer_entry_t;
-
-STATIC_ASSERT(sizeof(buffer_entry_t) % 4 == 0);
-
-/** Circular buffer list */
-typedef struct
-{
-    buffer_entry_t buffer[MAX_BUFFER_ENTRIES]; /**< Maximum number of entries that can enqueued in the list */
-    uint8_t        rp;                         /**< Index to the read location */
-    uint8_t        wp;                         /**< Index to write location */
-    uint8_t        count;                      /**< Number of elements in the list */
-} buffer_list_t;
-
-STATIC_ASSERT(sizeof(buffer_list_t) % 4 == 0);
-
 static ble_hids_t m_hids;                                   /**< Structure used to identify the HID service. */
 static ble_bas_t  m_bas;                                    /**< Structure used to identify the battery service. */
-static bool       m_in_boot_mode = false;                   /**< Current protocol mode. */
 static uint16_t   m_conn_handle  = BLE_CONN_HANDLE_INVALID; /**< Handle of the current connection. */
 
-static sensorsim_cfg_t   m_battery_sim_cfg;                 /**< Battery Level sensor simulator configuration. */
-static sensorsim_state_t m_battery_sim_state;               /**< Battery Level sensor simulator state. */
-
-APP_TIMER_DEF(m_battery_timer_id);                          /**< Battery timer. */
+APP_TIMER_DEF(m_input_timer_id);                          /**< Input timer. */
+static uint8_t report[INPUT_REPORT_LENGTH];
+static uint8_t report_count = 0;
 
 static pm_peer_id_t m_peer_id;                              /**< Device reference handle to the current bonded central. */
-static bool         m_caps_on = false;                      /**< Variable to indicate if Caps Lock is turned on. */
 
 static pm_peer_id_t   m_whitelist_peers[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];  /**< List of peers currently in the whitelist. */
 static uint32_t       m_whitelist_peer_cnt;                                 /**< Number of peers currently in the whitelist. */
@@ -226,41 +167,12 @@
 
 static ble_uuid_t m_adv_uuids[] = {{BLE_UUID_HUMAN_INTERFACE_DEVICE_SERVICE, BLE_UUID_TYPE_BLE}};
 
-static uint8_t m_sample_key_press_scan_str[] = /**< Key pattern to be sent when the key press button has been pushed. */
-{
-    0x0b,                                      /* Key h */
-    0x08,                                      /* Key e */
-    0x0f,                                      /* Key l */
-    0x0f,                                      /* Key l */
-    0x12,                                      /* Key o */
-    0x28                                       /* Key Return */
-};
-
-static uint8_t m_caps_on_key_scan_str[] = /**< Key pattern to be sent when the output report has been written with the CAPS LOCK bit set. */
-{
-    0x06,                                 /* Key C */
-    0x04,                                 /* Key a */
-    0x13,                                 /* Key p */
-    0x16,                                 /* Key s */
-    0x12,                                 /* Key o */
-    0x11,                                 /* Key n */
-};
-
-static uint8_t m_caps_off_key_scan_str[] = /**< Key pattern to be sent when the output report has been written with the CAPS LOCK bit cleared. */
-{
-    0x06,                                  /* Key C */
-    0x04,                                  /* Key a */
-    0x13,                                  /* Key p */
-    0x16,                                  /* Key s */
-    0x12,                                  /* Key o */
-    0x09,                                  /* Key f */
-};
-
-
-/** List to enqueue not just data to be sent, but also related information like the handle, connection handle etc */
-static buffer_list_t buffer_list;
-
 static void on_hids_evt(ble_hids_t * p_hids, ble_hids_evt_t * p_evt);
+static void sleep_mode_enter(void);
+static void send_report(void);
+#if !defined(ARCADE_INPUT)
+static uint32_t start_input = 10000;
+#endif
 
 /**@brief Callback function for asserts in the SoftDevice.
  *
@@ -502,38 +414,31 @@
 }
 
 
-/**@brief Function for performing a battery measurement, and update the Battery Level characteristic in the Battery Service.
- */
-static void battery_level_update(void)
+// Every ms
+static void input_timeout_handler(void * p_context)
 {
-    uint32_t err_code;
-    uint8_t  battery_level;
-
-    battery_level = (uint8_t)sensorsim_measure(&m_battery_sim_state, &m_battery_sim_cfg);
-
-    err_code = ble_bas_battery_level_update(&m_bas, battery_level);
-    if ((err_code != NRF_SUCCESS) &&
-        (err_code != NRF_ERROR_INVALID_STATE) &&
-        (err_code != BLE_ERROR_NO_TX_PACKETS) &&
-        (err_code != BLE_ERROR_GATTS_SYS_ATTR_MISSING)
-       )
+#if !defined(ARCADE_INPUT)
+    static uint8_t adc_counter = 0;
+    if(start_input == 0 && adc_counter++ > 10)
     {
-        APP_ERROR_HANDLER(err_code);
+        adc_counter = 0;
+        start_channels_sampling();
+    }
+    else if(start_input != 0)
+        start_input--;
+#endif
+    
+      if(joy_debounce_input())
+    {
+        send_report();
+        timeout_counter = TIMEOUT_IN_MS;
+    }
+    else if(--timeout_counter == 0)
+    {
+        NRF_LOG_INFO("TIMEOUT => GO TO SLEEP (TODO)\r\n");
+        sleep_mode_enter();
     }
-}
-
 
-/**@brief Function for handling the Battery measurement timer timeout.
- *
- * @details This function will be called each time the battery level measurement timer expires.
- *
- * @param[in]   p_context   Pointer used for passing some arbitrary information (context) from the
- *                          app_start_timer() call to the timeout handler.
- */
-static void battery_level_meas_timeout_handler(void * p_context)
-{
-    UNUSED_PARAMETER(p_context);
-    battery_level_update();
 }
 
 
@@ -548,11 +453,12 @@
     // Initialize timer module, making it use the scheduler.
     APP_TIMER_APPSH_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, true);
 
-    // Create battery timer.
-    err_code = app_timer_create(&m_battery_timer_id,
+    // Create input timer.
+    err_code = app_timer_create(&m_input_timer_id,
                                 APP_TIMER_MODE_REPEATED,
-                                battery_level_meas_timeout_handler);
+                                input_timeout_handler);
     APP_ERROR_CHECK(err_code);
+    
 }
 
 
@@ -574,7 +480,7 @@
                                           strlen(DEVICE_NAME));
     APP_ERROR_CHECK(err_code);
 
-    err_code = sd_ble_gap_appearance_set(BLE_APPEARANCE_HID_KEYBOARD);
+    err_code = sd_ble_gap_appearance_set(BLE_APPEARANCE_HID_GAMEPAD);
     APP_ERROR_CHECK(err_code);
 
     memset(&gap_conn_params, 0, sizeof(gap_conn_params));
@@ -583,6 +489,9 @@
     gap_conn_params.max_conn_interval = MAX_CONN_INTERVAL;
     gap_conn_params.slave_latency     = SLAVE_LATENCY;
     gap_conn_params.conn_sup_timeout  = CONN_SUP_TIMEOUT;
+                                                                                    
+    NRF_LOG_INFO("min : %d", MIN_CONN_INTERVAL);
+    NRF_LOG_INFO("max : %d", MAX_CONN_INTERVAL);
 
     err_code = sd_ble_gap_ppcp_set(&gap_conn_params);
     APP_ERROR_CHECK(err_code);
@@ -639,99 +548,100 @@
     APP_ERROR_CHECK(err_code);
 }
 
-
-/**@brief Function for initializing HID Service.
- */
 static void hids_init(void)
 {
     uint32_t                   err_code;
     ble_hids_init_t            hids_init_obj;
     ble_hids_inp_rep_init_t    input_report_array[1];
     ble_hids_inp_rep_init_t  * p_input_report;
-    ble_hids_outp_rep_init_t   output_report_array[1];
-    ble_hids_outp_rep_init_t * p_output_report;
     uint8_t                    hid_info_flags;
 
     memset((void *)input_report_array, 0, sizeof(ble_hids_inp_rep_init_t));
-    memset((void *)output_report_array, 0, sizeof(ble_hids_outp_rep_init_t));
-
+#if defined(ARCADE_INPUT)
     static uint8_t report_map_data[] =
     {
-        0x05, 0x01,       // Usage Page (Generic Desktop)
-        0x09, 0x06,       // Usage (Keyboard)
-        0xA1, 0x01,       // Collection (Application)
-        0x05, 0x07,       // Usage Page (Key Codes)
-        0x19, 0xe0,       // Usage Minimum (224)
-        0x29, 0xe7,       // Usage Maximum (231)
-        0x15, 0x00,       // Logical Minimum (0)
-        0x25, 0x01,       // Logical Maximum (1)
-        0x75, 0x01,       // Report Size (1)
-        0x95, 0x08,       // Report Count (8)
-        0x81, 0x02,       // Input (Data, Variable, Absolute)
-
-        0x95, 0x01,       // Report Count (1)
-        0x75, 0x08,       // Report Size (8)
-        0x81, 0x01,       // Input (Constant) reserved byte(1)
-
-        0x95, 0x05,       // Report Count (5)
-        0x75, 0x01,       // Report Size (1)
-        0x05, 0x08,       // Usage Page (Page# for LEDs)
-        0x19, 0x01,       // Usage Minimum (1)
-        0x29, 0x05,       // Usage Maximum (5)
-        0x91, 0x02,       // Output (Data, Variable, Absolute), Led report
-        0x95, 0x01,       // Report Count (1)
-        0x75, 0x03,       // Report Size (3)
-        0x91, 0x01,       // Output (Data, Variable, Absolute), Led report padding
-
-        0x95, 0x06,       // Report Count (6)
-        0x75, 0x08,       // Report Size (8)
-        0x15, 0x00,       // Logical Minimum (0)
-        0x25, 0x65,       // Logical Maximum (101)
-        0x05, 0x07,       // Usage Page (Key codes)
-        0x19, 0x00,       // Usage Minimum (0)
-        0x29, 0x65,       // Usage Maximum (101)
-        0x81, 0x00,       // Input (Data, Array) Key array(6 bytes)
-
-        0x09, 0x05,       // Usage (Vendor Defined)
-        0x15, 0x00,       // Logical Minimum (0)
-        0x26, 0xFF, 0x00, // Logical Maximum (255)
-        0x75, 0x08,       // Report Count (2)
-        0x95, 0x02,       // Report Size (8 bit)
-        0xB1, 0x02,       // Feature (Data, Variable, Absolute)
-
-        0xC0              // End Collection (Application)
+      0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
+      0x09, 0x05,                    // USAGE (Game Pad)
+      0xa1, 0x01,                    // COLLECTION (Application)
+      0xa1, 0x00,                    //   COLLECTION (Physical)
+      0x09, 0x30,                    //     USAGE (X)
+      0x09, 0x31,                    //     USAGE (Y)
+      0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
+      0x25, 0x02,                    //     LOGICAL_MAXIMUM (2)
+      0x35, 0xff,                    //     PHYSICAL_MINIMUM (-1)
+      0x45, 0x01,                    //     PHYSICAL_MAXIMUM (1)
+      0x95, 0x02,                    //     REPORT_COUNT (2)
+      0x75, 0x02,                    //     REPORT_SIZE (2)
+      0x81, 0x02,                    //     INPUT (Data,Var,Abs)
+      0x05, 0x09,                    //     USAGE_PAGE (Button)
+      0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
+      0x29, 0x0a,                    //     USAGE_MAXIMUM (Button 10)
+      0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
+      0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
+      0x95, 0x0a,                    //     REPORT_COUNT (10)
+      0x75, 0x01,                    //     REPORT_SIZE (1)
+      0x81, 0x02,                    //     INPUT (Data,Var,Abs)
+      0x95, 0x01,                    //     REPORT_COUNT (1)
+      0x75, 0x02,                    //     REPORT_SIZE (2)
+      0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
+      0xc0,                          //   END_COLLECTION
+      0xc0                           // END_COLLECTION
     };
-
+#else
+        static uint8_t report_map_data[] =
+    {
+      0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
+      0x09, 0x05,                    // USAGE (Game Pad)
+      0xa1, 0x01,                    // COLLECTION (Application)
+      0xa1, 0x00,                    //   COLLECTION (Physical)
+      0x09, 0x30,                    //     USAGE (X)
+      0x09, 0x31,                    //     USAGE (Y)
+      0x09, 0x33,                    //     USAGE (RX)
+      0x09, 0x34,                    //     USAGE (RY)
+      0x09, 0x35,                    //     USAGE (RZ)
+      0x09, 0x36,                    //     USAGE (Slider)
+      0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
+      0x26, 0xff, 0x00,                   //     LOGICAL_MAXIMUM (255)
+      0x75, 0x08,                     // REPORT_SIZE (8)
+      0x95, 0x04,                     // REPORT_COUNT (6)
+      0x81, 0x02,                     // INPUT (Data,Var,Abs)
+      0x05, 0x09,                     // USAGE_PAGE (Button)
+      0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
+      0x29, 0x10,                    //     USAGE_MAXIMUM (Button 14)
+      0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
+      0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
+      0x95, 0x10,                    //     REPORT_COUNT (14)
+      0x75, 0x01,                    //     REPORT_SIZE (1)
+      0x81, 0x02,                    //     INPUT (Data,Var,Abs)
+      0x95, 0x01,                    //     REPORT_COUNT (1)
+      0x75, 0x02,                    //     REPORT_SIZE (2)
+      0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
+      0xc0,                          //   END_COLLECTION
+      0xc0                           // END_COLLECTION
+    };
+#endif
     // Initialize HID Service
-    p_input_report                      = &input_report_array[INPUT_REPORT_KEYS_INDEX];
-    p_input_report->max_len             = INPUT_REPORT_KEYS_MAX_LEN;
-    p_input_report->rep_ref.report_id   = INPUT_REP_REF_ID;
+    p_input_report                      = &input_report_array[0];
+    p_input_report->max_len             = INPUT_REPORT_LENGTH;
+    p_input_report->rep_ref.report_id   = 0;
     p_input_report->rep_ref.report_type = BLE_HIDS_REP_TYPE_INPUT;
 
     BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&p_input_report->security_mode.cccd_write_perm);
     BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&p_input_report->security_mode.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&p_input_report->security_mode.write_perm);
 
-    p_output_report                      = &output_report_array[OUTPUT_REPORT_INDEX];
-    p_output_report->max_len             = OUTPUT_REPORT_MAX_LEN;
-    p_output_report->rep_ref.report_id   = OUTPUT_REP_REF_ID;
-    p_output_report->rep_ref.report_type = BLE_HIDS_REP_TYPE_OUTPUT;
-
-    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&p_output_report->security_mode.read_perm);
-    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&p_output_report->security_mode.write_perm);
-
     hid_info_flags = HID_INFO_FLAG_REMOTE_WAKE_MSK | HID_INFO_FLAG_NORMALLY_CONNECTABLE_MSK;
 
     memset(&hids_init_obj, 0, sizeof(hids_init_obj));
 
     hids_init_obj.evt_handler                    = on_hids_evt;
     hids_init_obj.error_handler                  = service_error_handler;
-    hids_init_obj.is_kb                          = true;
+    hids_init_obj.is_kb                          = false;
     hids_init_obj.is_mouse                       = false;
     hids_init_obj.inp_rep_count                  = 1;
     hids_init_obj.p_inp_rep_array                = input_report_array;
-    hids_init_obj.outp_rep_count                 = 1;
-    hids_init_obj.p_outp_rep_array               = output_report_array;
+    hids_init_obj.outp_rep_count                 = 0;
+    hids_init_obj.p_outp_rep_array               = NULL;
     hids_init_obj.feature_rep_count              = 0;
     hids_init_obj.p_feature_rep_array            = NULL;
     hids_init_obj.rep_map.data_len               = sizeof(report_map_data);
@@ -747,13 +657,6 @@
     BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.hid_information.security_mode.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&hids_init_obj.hid_information.security_mode.write_perm);
 
-    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(
-        &hids_init_obj.security_mode_boot_kb_inp_rep.cccd_write_perm);
-    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.security_mode_boot_kb_inp_rep.read_perm);
-    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&hids_init_obj.security_mode_boot_kb_inp_rep.write_perm);
-    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.security_mode_boot_kb_outp_rep.read_perm);
-    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.security_mode_boot_kb_outp_rep.write_perm);
-
     BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.security_mode_protocol.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&hids_init_obj.security_mode_protocol.write_perm);
     BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&hids_init_obj.security_mode_ctrl_point.read_perm);
@@ -774,19 +677,6 @@
 }
 
 
-/**@brief Function for initializing the battery sensor simulator.
- */
-static void sensor_simulator_init(void)
-{
-    m_battery_sim_cfg.min          = MIN_BATTERY_LEVEL;
-    m_battery_sim_cfg.max          = MAX_BATTERY_LEVEL;
-    m_battery_sim_cfg.incr         = BATTERY_LEVEL_INCREMENT;
-    m_battery_sim_cfg.start_at_max = true;
-
-    sensorsim_init(&m_battery_sim_state, &m_battery_sim_cfg);
-}
-
-
 /**@brief Function for handling a Connection Parameters error.
  *
  * @param[in]   nrf_error   Error code containing information about what went wrong.
@@ -820,364 +710,32 @@
 }
 
 
-/**@brief Function for starting timers.
- */
-static void timers_start(void)
-{
-    uint32_t err_code;
-
-    err_code = app_timer_start(m_battery_timer_id, BATTERY_LEVEL_MEAS_INTERVAL, NULL);
-    APP_ERROR_CHECK(err_code);
-}
-
-
-/** @brief   Function for checking if the Shift key is pressed.
- *
- *  @returns true if the SHIFT_BUTTON is pressed. false otherwise.
- */
-static bool is_shift_key_pressed(void)
-{
-    bool     result;
-    uint32_t err_code = bsp_button_is_pressed(SHIFT_BUTTON_ID, &result);
-
-    APP_ERROR_CHECK(err_code);
-    return result;
-}
-
-
-/**@brief   Function for transmitting a key scan Press & Release Notification.
- *
- * @warning This handler is an example only. You need to analyze how you wish to send the key
- *          release.
- *
- * @param[in]  p_instance     Identifies the service for which Key Notifications are requested.
- * @param[in]  p_key_pattern  Pointer to key pattern.
- * @param[in]  pattern_len    Length of key pattern. 0 < pattern_len < 7.
- * @param[in]  pattern_offset Offset applied to Key Pattern for transmission.
- * @param[out] actual_len     Provides actual length of Key Pattern transmitted, making buffering of
- *                            rest possible if needed.
- * @return     NRF_SUCCESS on success, BLE_ERROR_NO_TX_PACKETS in case transmission could not be
- *             completed due to lack of transmission buffer or other error codes indicating reason
- *             for failure.
- *
- * @note       In case of BLE_ERROR_NO_TX_PACKETS, remaining pattern that could not be transmitted
- *             can be enqueued \ref buffer_enqueue function.
- *             In case a pattern of 'cofFEe' is the p_key_pattern, with pattern_len as 6 and
- *             pattern_offset as 0, the notifications as observed on the peer side would be
- *             1>    'c', 'o', 'f', 'F', 'E', 'e'
- *             2>    -  , 'o', 'f', 'F', 'E', 'e'
- *             3>    -  ,   -, 'f', 'F', 'E', 'e'
- *             4>    -  ,   -,   -, 'F', 'E', 'e'
- *             5>    -  ,   -,   -,   -, 'E', 'e'
- *             6>    -  ,   -,   -,   -,   -, 'e'
- *             7>    -  ,   -,   -,   -,   -,  -
- *             Here, '-' refers to release, 'c' refers to the key character being transmitted.
- *             Therefore 7 notifications will be sent.
- *             In case an offset of 4 was provided, the pattern notifications sent will be from 5-7
- *             will be transmitted.
- */
-static uint32_t send_key_scan_press_release(ble_hids_t * p_hids,
-                                            uint8_t    * p_key_pattern,
-                                            uint16_t     pattern_len,
-                                            uint16_t     pattern_offset,
-                                            uint16_t   * p_actual_len)
-{
-    uint32_t err_code;
-    uint16_t offset;
-    uint16_t data_len;
-    uint8_t  data[INPUT_REPORT_KEYS_MAX_LEN];
-
-    // HID Report Descriptor enumerates an array of size 6, the pattern hence shall not be any
-    // longer than this.
-    STATIC_ASSERT((INPUT_REPORT_KEYS_MAX_LEN - 2) == 6);
-
-    ASSERT(pattern_len <= (INPUT_REPORT_KEYS_MAX_LEN - 2));
-
-    offset   = pattern_offset;
-    data_len = pattern_len;
-
-    do
-    {
-        // Reset the data buffer.
-        memset(data, 0, sizeof(data));
-
-        // Copy the scan code.
-        memcpy(data + SCAN_CODE_POS + offset, p_key_pattern + offset, data_len - offset);
-
-        if (is_shift_key_pressed())
-        {
-            data[MODIFIER_KEY_POS] |= SHIFT_KEY_CODE;
-        }
-
-        if (!m_in_boot_mode)
-        {
-            err_code = ble_hids_inp_rep_send(p_hids,
-                                             INPUT_REPORT_KEYS_INDEX,
-                                             INPUT_REPORT_KEYS_MAX_LEN,
-                                             data);
-        }
-        else
-        {
-            err_code = ble_hids_boot_kb_inp_rep_send(p_hids,
-                                                     INPUT_REPORT_KEYS_MAX_LEN,
-                                                     data);
-        }
-
-        if (err_code != NRF_SUCCESS)
-        {
-            break;
-        }
-
-        offset++;
-    }
-    while (offset <= data_len);
-
-    *p_actual_len = offset;
-
-    return err_code;
-}
-
-
-/**@brief   Function for initializing the buffer queue used to key events that could not be
- *          transmitted
- *
- * @warning This handler is an example only. You need to analyze how you wish to buffer or buffer at
- *          all.
- *
- * @note    In case of HID keyboard, a temporary buffering could be employed to handle scenarios
- *          where encryption is not yet enabled or there was a momentary link loss or there were no
- *          Transmit buffers.
- */
-static void buffer_init(void)
-{
-    uint32_t buffer_count;
-
-    BUFFER_LIST_INIT();
-
-    for (buffer_count = 0; buffer_count < MAX_BUFFER_ENTRIES; buffer_count++)
-    {
-        BUFFER_ELEMENT_INIT(buffer_count);
-    }
-}
-
-
-/**@brief Function for enqueuing key scan patterns that could not be transmitted either completely
- *        or partially.
- *
- * @warning This handler is an example only. You need to analyze how you wish to send the key
- *          release.
- *
- * @param[in]  p_hids         Identifies the service for which Key Notifications are buffered.
- * @param[in]  p_key_pattern  Pointer to key pattern.
- * @param[in]  pattern_len    Length of key pattern.
- * @param[in]  offset         Offset applied to Key Pattern when requesting a transmission on
- *                            dequeue, @ref buffer_dequeue.
- * @return     NRF_SUCCESS on success, else an error code indicating reason for failure.
- */
-static uint32_t buffer_enqueue(ble_hids_t * p_hids,
-                               uint8_t    * p_key_pattern,
-                               uint16_t     pattern_len,
-                               uint16_t     offset)
-{
-    buffer_entry_t * element;
-    uint32_t         err_code = NRF_SUCCESS;
-
-    if (BUFFER_LIST_FULL())
-    {
-        // Element cannot be buffered.
-        err_code = NRF_ERROR_NO_MEM;
-    }
-    else
-    {
-        // Make entry of buffer element and copy data.
-        element              = &buffer_list.buffer[(buffer_list.wp)];
-        element->p_instance  = p_hids;
-        element->p_data      = p_key_pattern;
-        element->data_offset = offset;
-        element->data_len    = pattern_len;
-
-        buffer_list.count++;
-        buffer_list.wp++;
-
-        if (buffer_list.wp == MAX_BUFFER_ENTRIES)
-        {
-            buffer_list.wp = 0;
-        }
-    }
-
-    return err_code;
-}
-
-
-/**@brief   Function to dequeue key scan patterns that could not be transmitted either completely of
- *          partially.
- *
- * @warning This handler is an example only. You need to analyze how you wish to send the key
- *          release.
- *
- * @param[in]  tx_flag   Indicative of whether the dequeue should result in transmission or not.
- * @note       A typical example when all keys are dequeued with transmission is when link is
- *             disconnected.
- *
- * @return     NRF_SUCCESS on success, else an error code indicating reason for failure.
- */
-static uint32_t buffer_dequeue(bool tx_flag)
-{
-    buffer_entry_t * p_element;
-    uint32_t         err_code = NRF_SUCCESS;
-    uint16_t         actual_len;
-
-    if (BUFFER_LIST_EMPTY())
-    {
-        err_code = NRF_ERROR_NOT_FOUND;
-    }
-    else
-    {
-        bool remove_element = true;
-
-        p_element = &buffer_list.buffer[(buffer_list.rp)];
-
-        if (tx_flag)
-        {
-            err_code = send_key_scan_press_release(p_element->p_instance,
-                                                   p_element->p_data,
-                                                   p_element->data_len,
-                                                   p_element->data_offset,
-                                                   &actual_len);
-            // An additional notification is needed for release of all keys, therefore check
-            // is for actual_len <= element->data_len and not actual_len < element->data_len
-            if ((err_code == BLE_ERROR_NO_TX_PACKETS) && (actual_len <= p_element->data_len))
-            {
-                // Transmission could not be completed, do not remove the entry, adjust next data to
-                // be transmitted
-                p_element->data_offset = actual_len;
-                remove_element         = false;
-            }
-        }
-
-        if (remove_element)
-        {
-            BUFFER_ELEMENT_INIT(buffer_list.rp);
-
-            buffer_list.rp++;
-            buffer_list.count--;
-
-            if (buffer_list.rp == MAX_BUFFER_ENTRIES)
-            {
-                buffer_list.rp = 0;
-            }
-        }
-    }
-
-    return err_code;
-}
-
-
-/**@brief Function for sending sample key presses to the peer.
- *
- * @param[in]   key_pattern_len   Pattern length.
- * @param[in]   p_key_pattern     Pattern to be sent.
- */
-static void keys_send(uint8_t key_pattern_len, uint8_t * p_key_pattern)
-{
-    uint32_t err_code;
-    uint16_t actual_len;
-
-    err_code = send_key_scan_press_release(&m_hids,
-                                           p_key_pattern,
-                                           key_pattern_len,
-                                           0,
-                                           &actual_len);
-    // An additional notification is needed for release of all keys, therefore check
-    // is for actual_len <= key_pattern_len and not actual_len < key_pattern_len.
-    if ((err_code == BLE_ERROR_NO_TX_PACKETS) && (actual_len <= key_pattern_len))
-    {
-        // Buffer enqueue routine return value is not intentionally checked.
-        // Rationale: Its better to have a a few keys missing than have a system
-        // reset. Recommendation is to work out most optimal value for
-        // MAX_BUFFER_ENTRIES to minimize chances of buffer queue full condition
-        UNUSED_VARIABLE(buffer_enqueue(&m_hids, p_key_pattern, key_pattern_len, actual_len));
-    }
-
-
-    if ((err_code != NRF_SUCCESS) &&
-        (err_code != NRF_ERROR_INVALID_STATE) &&
-        (err_code != BLE_ERROR_NO_TX_PACKETS) &&
-        (err_code != BLE_ERROR_GATTS_SYS_ATTR_MISSING)
-       )
-    {
-        APP_ERROR_HANDLER(err_code);
-    }
-}
-
-
-/**@brief Function for handling the HID Report Characteristic Write event.
- *
- * @param[in]   p_evt   HID service event.
- */
-static void on_hid_rep_char_write(ble_hids_evt_t * p_evt)
-{
-    if (p_evt->params.char_write.char_id.rep_type == BLE_HIDS_REP_TYPE_OUTPUT)
-    {
-        uint32_t err_code;
-        uint8_t  report_val;
-        uint8_t  report_index = p_evt->params.char_write.char_id.rep_index;
-
-        if (report_index == OUTPUT_REPORT_INDEX)
-        {
-            // This code assumes that the outptu report is one byte long. Hence the following
-            // static assert is made.
-            STATIC_ASSERT(OUTPUT_REPORT_MAX_LEN == 1);
-
-            err_code = ble_hids_outp_rep_get(&m_hids,
-                                             report_index,
-                                             OUTPUT_REPORT_MAX_LEN,
-                                             0,
-                                             &report_val);
-            APP_ERROR_CHECK(err_code);
-
-            if (!m_caps_on && ((report_val & OUTPUT_REPORT_BIT_MASK_CAPS_LOCK) != 0))
-            {
-                // Caps Lock is turned On.
-                NRF_LOG_INFO("Caps Lock is turned On!\r\n");
-                err_code = bsp_indication_set(BSP_INDICATE_ALERT_3);
-                APP_ERROR_CHECK(err_code);
-
-                keys_send(sizeof(m_caps_on_key_scan_str), m_caps_on_key_scan_str);
-                m_caps_on = true;
-            }
-            else if (m_caps_on && ((report_val & OUTPUT_REPORT_BIT_MASK_CAPS_LOCK) == 0))
-            {
-                // Caps Lock is turned Off .
-                NRF_LOG_INFO("Caps Lock is turned Off!\r\n");
-                err_code = bsp_indication_set(BSP_INDICATE_ALERT_OFF);
-                APP_ERROR_CHECK(err_code);
-
-                keys_send(sizeof(m_caps_off_key_scan_str), m_caps_off_key_scan_str);
-                m_caps_on = false;
-            }
-            else
-            {
-                // The report received is not supported by this application. Do nothing.
-            }
-        }
-    }
-}
-
-
 /**@brief Function for putting the chip into sleep mode.
  *
  * @note This function will not return.
  */
 static void sleep_mode_enter(void)
 {
-    uint32_t err_code = bsp_indication_set(BSP_INDICATE_IDLE);
-
-    APP_ERROR_CHECK(err_code);
+     uint32_t err_code;
+     NRF_LOG_INFO("sleep_mode_enter\r\n");
+     joy_input_prepare_to_sleep();
+
+    // Disable UART transmission and reception
+#if NRF_LOG_ENABLED
+    NRF_UART0->TASKS_STOPRX = 1;
+    NRF_UART0->TASKS_STOPTX = 1;
+    // Disable UART to get control of GPIOs
+    NRF_UART0->ENABLE = UART_ENABLE_ENABLE_Disabled << UART_ENABLE_ENABLE_Pos;
+
+    nrf_gpio_cfg_sense_input(NRF_LOG_BACKEND_SERIAL_UART_TX_PIN, NRF_GPIO_PIN_PULLUP, NRF_GPIO_PIN_NOSENSE);
+    nrf_gpio_cfg_sense_input(NRF_LOG_BACKEND_SERIAL_UART_RX_PIN, NRF_GPIO_PIN_PULLUP, NRF_GPIO_PIN_NOSENSE);
+    nrf_gpio_cfg_sense_input(NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN, NRF_GPIO_PIN_PULLUP, NRF_GPIO_PIN_NOSENSE);
+    nrf_gpio_cfg_sense_input(NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN, NRF_GPIO_PIN_PULLUP, NRF_GPIO_PIN_NOSENSE);
+#endif
 
-    // Prepare wakeup buttons.
-    err_code = bsp_btn_ble_sleep_mode_prepare();
-    APP_ERROR_CHECK(err_code);
+#if DEBUG
+    timer_stop();    
+#endif
 
     // Go to system-off mode (this function will not return; wakeup will cause a reset).
     err_code = sd_power_system_off();
@@ -1194,27 +752,10 @@
  */
 static void on_hids_evt(ble_hids_t * p_hids, ble_hids_evt_t * p_evt)
 {
-    switch (p_evt->evt_type)
+    /*switch (p_evt->evt_type)
     {
-        case BLE_HIDS_EVT_BOOT_MODE_ENTERED:
-            m_in_boot_mode = true;
-            break;
-
-        case BLE_HIDS_EVT_REPORT_MODE_ENTERED:
-            m_in_boot_mode = false;
-            break;
-
-        case BLE_HIDS_EVT_REP_CHAR_WRITE:
-            on_hid_rep_char_write(p_evt);
-            break;
-
-        case BLE_HIDS_EVT_NOTIF_ENABLED:
-            break;
-
-        default:
-            // No implementation needed.
-            break;
-    }
+       case BLE_HIDS_EVT_BOOT_MODE_ENTERED:
+    }*/
 }
 
 
@@ -1232,32 +773,22 @@
     {
         case BLE_ADV_EVT_DIRECTED:
             NRF_LOG_INFO("BLE_ADV_EVT_DIRECTED\r\n");
-            err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING_DIRECTED);
-            APP_ERROR_CHECK(err_code);
             break; //BLE_ADV_EVT_DIRECTED
 
         case BLE_ADV_EVT_FAST:
             NRF_LOG_INFO("BLE_ADV_EVT_FAST\r\n");
-            err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING);
-            APP_ERROR_CHECK(err_code);
             break; //BLE_ADV_EVT_FAST
 
         case BLE_ADV_EVT_SLOW:
             NRF_LOG_INFO("BLE_ADV_EVT_SLOW\r\n");
-            err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING_SLOW);
-            APP_ERROR_CHECK(err_code);
             break; //BLE_ADV_EVT_SLOW
 
         case BLE_ADV_EVT_FAST_WHITELIST:
             NRF_LOG_INFO("BLE_ADV_EVT_FAST_WHITELIST\r\n");
-            err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING_WHITELIST);
-            APP_ERROR_CHECK(err_code);
             break; //BLE_ADV_EVT_FAST_WHITELIST
 
         case BLE_ADV_EVT_SLOW_WHITELIST:
             NRF_LOG_INFO("BLE_ADV_EVT_SLOW_WHITELIST\r\n");
-            err_code = bsp_indication_set(BSP_INDICATE_ADVERTISING_WHITELIST);
-            APP_ERROR_CHECK(err_code);
             break; //BLE_ADV_EVT_SLOW_WHITELIST
 
         case BLE_ADV_EVT_IDLE:
@@ -1308,6 +839,28 @@
     }
 }
 
+static void hid_connected(bool isConnected)
+{
+    uint32_t err_code;
+    NRF_LOG_INFO("hid_connected method\r\n");
+    if(isConnected)
+    {
+     memset(report, 0xFF, INPUT_REPORT_LENGTH);
+#if !defined(ARCADE_INPUT)
+        start_input = 10000;
+#endif
+        joy_input_reset();
+        //report_period_counter = 0;
+        timeout_counter = TIMEOUT_IN_MS;
+        err_code = app_timer_start(m_input_timer_id, TIMER_INPUT_TICK, NULL);
+    }
+    else
+    {
+        err_code = app_timer_stop(m_input_timer_id);
+    }
+    APP_ERROR_CHECK(err_code);
+}
+
 
 /**@brief Function for handling the Application's BLE Stack events.
  *
@@ -1320,32 +873,31 @@
     switch (p_ble_evt->header.evt_id)
     {
         case BLE_GAP_EVT_CONNECTED:
-            NRF_LOG_INFO("Connected\r\n");
-            err_code = bsp_indication_set(BSP_INDICATE_CONNECTED);
-            APP_ERROR_CHECK(err_code);
-
+            hid_connected(true);
             m_conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
+            NRF_LOG_INFO("Connected, interval min: %d, max: %d, latency: %d\r\n", 
+                                                    p_ble_evt->evt.gap_evt.params.conn_param_update_request.conn_params.min_conn_interval,
+                                                    p_ble_evt->evt.gap_evt.params.conn_param_update_request.conn_params.max_conn_interval,
+                                                    p_ble_evt->evt.gap_evt.params.conn_param_update_request.conn_params.slave_latency);
             break; // BLE_GAP_EVT_CONNECTED
 
+        case BLE_GAP_EVT_CONN_PARAM_UPDATE:
+            NRF_LOG_INFO("Param updated, interval min: %d, max: %d, latency: %d\r\n", 
+            p_ble_evt->evt.gap_evt.params.conn_param_update_request.conn_params.min_conn_interval,
+            p_ble_evt->evt.gap_evt.params.conn_param_update_request.conn_params.max_conn_interval,
+            p_ble_evt->evt.gap_evt.params.conn_param_update_request.conn_params.slave_latency);
+            break;//BLE_GAP_EVT_CONN_PARAM_UPDATE:
+
         case BLE_EVT_TX_COMPLETE:
-            // Send next key event
-            (void) buffer_dequeue(true);
+                    report_count -= p_ble_evt->evt.common_evt.params.tx_complete.count;
+                //NRF_LOG_RAW_INFO("txcom %d\r\n", report_count);
             break; // BLE_EVT_TX_COMPLETE
 
         case BLE_GAP_EVT_DISCONNECTED:
             NRF_LOG_INFO("Disconnected\r\n");
-            // Dequeue all keys without transmission.
-            (void) buffer_dequeue(false);
-
+            hid_connected(false);
             m_conn_handle = BLE_CONN_HANDLE_INVALID;
 
-            // Reset m_caps_on variable. Upon reconnect, the HID host will re-send the Output
-            // report containing the Caps lock state.
-            m_caps_on = false;
-            // disabling alert 3. signal - used for capslock ON
-            err_code = bsp_indication_set(BSP_INDICATE_ALERT_OFF);
-            APP_ERROR_CHECK(err_code);
-
             if (m_is_wl_changed)
             {
                 // The whitelist has been modified, update it in the Peer Manager.
@@ -1420,7 +972,12 @@
             break; // BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST
 #endif
 
+        case BLE_GAP_EVT_TIMEOUT:
+            NRF_LOG_INFO("BLE_GAP_EVT_TIMEOUT.\r\n");
+            break;
+                
         default:
+            //NRF_LOG_INFO("BLE_GAP %d.\r\n", p_ble_evt->header.evt_id);
             // No implementation needed.
             break;
     }
@@ -1440,7 +997,6 @@
      * Remember to call ble_conn_state_on_ble_evt before calling any ble_conns_state_* functions. */
     ble_conn_state_on_ble_evt(p_ble_evt);
     pm_on_ble_evt(p_ble_evt);
-    bsp_btn_ble_on_ble_evt(p_ble_evt);
     on_ble_evt(p_ble_evt);
     ble_advertising_on_ble_evt(p_ble_evt);
     ble_conn_params_on_ble_evt(p_ble_evt);
@@ -1516,62 +1072,6 @@
 }
 
 
-/**@brief Function for handling events from the BSP module.
- *
- * @param[in]   event   Event generated by button press.
- */
-static void bsp_event_handler(bsp_event_t event)
-{
-    uint32_t         err_code;
-    static uint8_t * p_key = m_sample_key_press_scan_str;
-    static uint8_t   size  = 0;
-
-    switch (event)
-    {
-        case BSP_EVENT_SLEEP:
-            sleep_mode_enter();
-            break;
-
-        case BSP_EVENT_DISCONNECT:
-            err_code = sd_ble_gap_disconnect(m_conn_handle,
-                                             BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);
-            if (err_code != NRF_ERROR_INVALID_STATE)
-            {
-                APP_ERROR_CHECK(err_code);
-            }
-            break;
-
-        case BSP_EVENT_WHITELIST_OFF:
-            if (m_conn_handle == BLE_CONN_HANDLE_INVALID)
-            {
-                err_code = ble_advertising_restart_without_whitelist();
-                if (err_code != NRF_ERROR_INVALID_STATE)
-                {
-                    APP_ERROR_CHECK(err_code);
-                }
-            }
-            break;
-
-        case BSP_EVENT_KEY_0:
-            if (m_conn_handle != BLE_CONN_HANDLE_INVALID)
-            {
-                keys_send(1, p_key);
-                p_key++;
-                size++;
-                if (size == MAX_KEYS_IN_ONE_REPORT)
-                {
-                    p_key = m_sample_key_press_scan_str;
-                    size  = 0;
-                }
-            }
-            break;
-
-        default:
-            break;
-    }
-}
-
-
 /**@brief Function for the Peer Manager initialization.
  *
  * @param[in] erase_bonds  Indicates whether bonding information should be cleared from
@@ -1655,25 +1155,114 @@
     APP_ERROR_CHECK(err_code);
 }
 
+static void send_report(void)
+{
+    static uint8_t new_report[INPUT_REPORT_LENGTH];
+    uint32_t status;
+    bool must_send_report = false;
+    
+    joy_get_report(new_report);
+    if(memcmp(new_report, report, INPUT_REPORT_LENGTH) != 0)
+    {
+        must_send_report = true;
+    }
+
+    if(must_send_report && report_count < 3)
+    {
+        status = ble_hids_inp_rep_send(&m_hids, 0, INPUT_REPORT_LENGTH, new_report);
+        
+        if(status == NRF_SUCCESS)
+        {
+            report_count++;
+            memcpy(report, new_report, sizeof(uint8_t) * INPUT_REPORT_LENGTH);
+        }
+    }
+}
 
-/**@brief Function for initializing buttons and leds.
- *
- * @param[out] p_erase_bonds  Will be true if the clear bonding button was pressed to wake the application up.
- */
-static void buttons_leds_init(bool * p_erase_bonds)
+void radio_event_handler(bool active)
 {
-    bsp_event_t startup_event;
+    uint32_t err_code;
+    static uint32_t vcc_counter = 0;
+    if(m_conn_handle == BLE_CONN_HANDLE_INVALID)
+    {
+        return;
+    }
+    
+    if(active)
+    {
+        //NRF_LOG_INFO("%zu:ronn\r\n", millis());
+#if defined(ARCADE_INPUT)
+        //err_code = app_sched_event_put(NULL,0,(app_sched_event_handler_t)send_report);
+        //APP_ERROR_CHECK(err_code);
+#else //ANALOG
+        //NRF_LOG_INFO("%zu:s\r\n", micros());
+        //err_code = app_sched_event_put(NULL,0,(app_sched_event_handler_t)start_channels_sampling);
+        //APP_ERROR_CHECK(err_code);
+#endif
+    }
+    else
+    {
+#ifdef DEBUG
+        if((++vcc_counter) >= 100)
+#else
+        if((++vcc_counter) >= 10000)
+#endif
+        {
+            //NRF_LOG_INFO("%zu:adc\r\n", micros());
+            vcc_counter = 0;
+            err_code = app_sched_event_put(NULL,0,(app_sched_event_handler_t)start_vcc_sampling);
+            APP_ERROR_CHECK(err_code);
+        }
+    }
+}
 
-    uint32_t err_code = bsp_init(BSP_INIT_LED | BSP_INIT_BUTTONS,
-                                 APP_TIMER_TICKS(100, APP_TIMER_PRESCALER),
-                                 bsp_event_handler);
+static void radio_event_init(void)
+{
+#if defined(ARCADE_INPUT)
+    uint32_t err_code = ble_radio_notification_init(3, NRF_RADIO_NOTIFICATION_DISTANCE_800US,radio_event_handler);
+#else
+    uint32_t err_code = ble_radio_notification_init(3, NRF_RADIO_NOTIFICATION_DISTANCE_3620US,radio_event_handler);
+#endif
+        APP_ERROR_CHECK(err_code);
+}
 
-    APP_ERROR_CHECK(err_code);
+void send_battery_level(void)
+{
+    uint32_t err_code;
+    static uint8_t adc_result_percent = 0;
+    uint8_t new_adc_result_percent = get_vcc_pct();
+
+        if(new_adc_result_percent == adc_result_percent)
+            return;
+        
+        adc_result_percent = new_adc_result_percent;
+        err_code = ble_bas_battery_level_update(&m_bas, adc_result_percent);           //Send the battery level over BLE
+        if ((err_code != NRF_SUCCESS) &&
+                (err_code != NRF_ERROR_INVALID_STATE) &&                                   
+                (err_code != BLE_ERROR_NO_TX_PACKETS) &&                                   
+                (err_code != BLE_ERROR_GATTS_SYS_ATTR_MISSING))
+        {
+            APP_ERROR_HANDLER(err_code);                                               //Assert on error
+        }
+        if (err_code == NRF_SUCCESS)
+            report_count++;
+}
 
-    err_code = bsp_btn_ble_init(NULL, &startup_event);
-    APP_ERROR_CHECK(err_code);
 
-    *p_erase_bonds = (startup_event == BSP_EVENT_CLEAR_BONDING_DATA);
+void joy_input_event_handler(uint8_t event)
+{
+    if(event == ADC_VCC_FINISH)
+    {
+        uint32_t err_code;
+        err_code = app_sched_event_put(NULL,0,(app_sched_event_handler_t)send_battery_level);
+        APP_ERROR_CHECK(err_code);
+    }
+    else if(event == ADC_CHANNEL_FINISH)
+    {
+        //uint32_t err_code;
+        /*err_code = app_sched_event_put(NULL,0,(app_sched_event_handler_t)send_report);
+        APP_ERROR_CHECK(err_code);*/
+    }
 }
 
 
@@ -1697,11 +1286,11 @@
     // Initialize.
     err_code = NRF_LOG_INIT(NULL);
     APP_ERROR_CHECK(err_code);
-
-    timers_init();
-    buttons_leds_init(&erase_bonds);
+    joy_input_init(joy_input_event_handler);
     ble_stack_init();
     scheduler_init();
+    timers_init();
+    erase_bonds = joy_get_bind_button_state();
     peer_manager_init(erase_bonds);
     if (erase_bonds == true)
     {
@@ -1710,13 +1299,13 @@
     gap_params_init();
     advertising_init();
     services_init();
-    sensor_simulator_init();
     conn_params_init();
-    buffer_init();
-
     // Start execution.
-    NRF_LOG_INFO("HID Keyboard Start!\r\n");
-    timers_start();
+    NRF_LOG_INFO("HID Gamepad Start!\r\n");
+#ifdef DEBUG
+    timer_micros_init();
+#endif
+    radio_event_init();
     advertising_start();
 
     // Enter main loop.
@@ -1731,6 +1320,3 @@
 }
 
 
-/**
- * @}
- */
